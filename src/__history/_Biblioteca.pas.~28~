unit _Biblioteca;

interface

uses
  SysUtils;

function ValidarCpfCnpj(numero: String): Boolean;
function ApenasNumerosStr(valor: String): String;
function IIf(condicao:Boolean; verdadeiro, falso: Variant): Variant;

implementation

function ValidarCpfCnpj(numero : String): Boolean;
Var
  i, d, b, digito : Byte;
  soma : Integer;
  cnpj : Boolean;
  DgPass, DgCalc : String;
begin
  Result := False;
  numero := ApenasNumerosStr(numero);

  // Caso o número não seja 11 (CPF) ou 14 (CNPJ), aborta
  Case Length(numero) of
    11: cnpj := False;
    14: cnpj := True;
  else
    Exit;
  end;

  // Separa o número do digito
  DgCalc := '';
  DgPass := Copy(numero, Length(numero) - 1, 2);
  numero := Copy(numero, 1, Length(numero) - 2);

  // Calcula o digito 1 e 2
  For d := 1 to 2 do begin
    b := IIf(d = 1, 2, 3); // BYTE
    soma := IIf(d = 1, 0, StrToIntDef(DgCalc, 0) * 2);

    for i := Length(numero) downto 1 do begin
      soma := soma + (Ord(numero[I]) - Ord('0')) * b;
      Inc(b);

      if (b > 9) And cnpj then
        b := 2;
    end;

    digito := 11 - soma mod 11;
    if digito >= 10 then
      digito := 0;

    DgCalc := DgCalc + Chr(digito + Ord('0'));
  end;

  Result := DgCalc = DgPass;
end;

function ApenasNumerosStr(valor: String): String;
var
  i: Integer;
begin
  Result := '';
  for i := 1 To Length(valor) do begin
    if valor[i] in ['1','2','3','4','5','6','7','8','9','0'] then
      Result := Result + valor[i];
  end;
end;

function IIf(condicao:Boolean; verdadeiro, falso: Variant): Variant;
begin
  if condicao then
    Result := verdadeiro
  else
    Result := falso;
end;

end.
